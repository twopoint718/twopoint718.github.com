<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>sencjw - named parameters in haskell</title>
    <link rel="stylesheet" type="text/css" href="../css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <link href="../atom.xml" type="application/atom+xml" rel="alternate" />
    <link href="../feed.rss" type="application/rss+xml" rel="alternate" />
  </head>
  <body>
    <div class="content">

      <header>
        <h1>sencjw</h1>
        <h2>a place I put stuff</h2>
      </header>

      <nav>
        <ul>
          <li><a href="../">Home</a></li>
          <li><a href="../archive.html">Blog Archive</a></li>
          <li><a href="../contact.html">Contact</a></li>
          <li><a href="../interviews.html">Interviews</a></li>
          <li><a href="../talks.html">Talks</a></li>
          <li><a href="../the_square_root_of_christmas.html">The Square Root of Christmas</a></li>
          <li><a href="../transparent_web.html">The Transparent Web (book)</a></li>
          <li><a href="../writings.html">Writings</a></li>
        </ul>
      </nav>

      <main>
        <article>
  <header>
    <h1>named parameters in haskell</h1>
    <p>
      Posted on September 14, 2013
      
    </p>
  </header>

  <p>I was watching <a href="https://www.youtube.com/watch?v=rI8tNMsozo0">Rich Hickey’s keynote</a> for Rails Conf 2012. I’ve been watching a lot of talks lately because I’ve organized a series of conference talk screenings at my work. And that’s probably a different blog post…</p>
<p>Anyhow, one thing that he mentioned that I don’t often think about is the complexity introduced with positional parameters. Let me explain:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">foo</span>(x, y, z,) {...}</code></pre>
<p>Requires that x, y, and z all be present in that exact order even if that’s not important:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">make_person</span>(first, last, phone) {...}
<span class="kw">function</span> <span class="fu">make_person</span>(last, first, phone) {...}
<span class="kw">function</span> <span class="fu">make_person</span>(phone, first, last) {...}</code></pre>
<p>If you encountered a wild <code>make_person</code>, you’d have to know which definition was the one that was used. The point is it really doesn’t matter that a person’s attributes are listed in that order. Any order is fine. But you’ve, implicitly, introduced a strict order-dependence here. Passing in a map/object/hash fixes this issue<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">make_person</span>(opts) {
  opts[<span class="st">'first'</span>] = ...
  <span class="fu">opts</span>[<span class="st">'last'</span>] = ...
  <span class="fu">opts</span>[<span class="st">'phone'</span>] = ...
}</code></pre>
<p>Haskell is pretty tied to the positional and unnamed argument thing. I was looking into how to do named and/or non-positional arguments.</p>
<h3 id="datatype">Datatype</h3>
<p>The first thing that occurred to me is to do something like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Text.Printf

<span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot"> firstName ::</span> <span class="dt">String</span>
                     ,<span class="ot"> lastName ::</span> <span class="dt">String</span>
                     ,<span class="ot"> email ::</span> <span class="dt">String</span>
                     }

<span class="ot">formatAddress ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
formatAddress p <span class="fu">=</span> printf <span class="st">&quot;\&quot;%s %s\&quot; &lt;%s&gt;&quot;</span> f l e
  <span class="kw">where</span>
    f <span class="fu">=</span> firstName p
    l <span class="fu">=</span> lastName p
    e <span class="fu">=</span> email p</code></pre>
<p>And then I call it like so:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">formatAddress <span class="dt">Person</span> { firstName <span class="fu">=</span> <span class="st">&quot;Chris&quot;</span>
                     , lastName <span class="fu">=</span> <span class="st">&quot;Wilson&quot;</span>
                     , email <span class="fu">=</span> <span class="st">&quot;chris@bendyworks.com&quot;</span>
                     }</code></pre>
<p>A slightly better tweak is to create a default that provides values for anything that’s missing (assuming that I have a function that just calls for one parameter):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">formatEmail p <span class="fu">=</span> printf <span class="st">&quot;&lt;%s&gt;&quot;</span> (email p)

defaultPerson <span class="fu">=</span> <span class="dt">Person</span> {firstName <span class="fu">=</span> <span class="st">&quot;&quot;</span>, lastName <span class="fu">=</span> <span class="st">&quot;&quot;</span>, email <span class="fu">=</span> <span class="st">&quot;&quot;</span>}</code></pre>
<p>But that “infects” the call site with the <code>defaultPerson</code> argument:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">formatEmail defaultPerson {email<span class="fu">=</span><span class="st">&quot;chris@bendyworks.com&quot;</span>}</code></pre>
<p>All the other, irrelevant arguments are defaulted by the <code>defaultPerson</code> constructor.</p>
<h3 id="named-records">Named Records</h3>
<p>This pulls in the big guns of template Haskell to abstract machinery something like what is spelled out above:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">import</span> Data.NamedRecord
<span class="kw">import</span> Text.Printf
<span class="kw">import</span> Data.Name

name <span class="st">&quot;firstName&quot;</span>
name <span class="st">&quot;lastName&quot;</span>
name <span class="st">&quot;email&quot;</span>

record <span class="st">&quot;Person&quot;</span>
    <span class="ot">`has`</span> <span class="st">&quot;firstName&quot;</span> <span class="fu">:=</span> <span class="ch">''</span><span class="dt">String</span>
    <span class="ot">`has`</span> <span class="st">&quot;lastName&quot;</span>  <span class="fu">:=</span> <span class="ch">''</span><span class="dt">String</span>
    <span class="ot">`has`</span> <span class="st">&quot;email&quot;</span>     <span class="fu">:=</span> <span class="ch">''</span><span class="dt">String</span>

<span class="ot">formatEmail ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
formatEmail p <span class="fu">=</span> printf <span class="st">&quot;&lt;%s&gt;&quot;</span> e
  <span class="kw">where</span>
    e <span class="fu">=</span> p <span class="ot">`get`</span> email</code></pre>
<p>But it has a rather pleasant usage:</p>
<pre><code>formatEmail (newPerson `set` email := &quot;chris@bendyworks.com&quot;)</code></pre>
<p>There is also a nice way to do <a href="http://hackage.haskell.org/packages/archive/named-records/0.5/doc/html/Data-NamedRecord.html">default arguments</a>. Go check it out, the docs are good.</p>
<h3 id="lenses">Lenses</h3>
<p>Okay, I have to admit that I’m less sure about this. Metaphor-weary haskellers please forgive me, but lenses seem to be the space-based laser (SBL) of the Haskell world right now. While the idea is simple, you’d like a way to pinpoint a structure for observation or (destructive) modification, the actual infrastructure surrounding it is rather elaborate. On the <a href="https://www.youtube.com/watch?v=D6sva6hGJ-s">Haskell Cast #1</a>, Edward Kmett goes into the details of the lens library. A few “<a href="http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/">lenses are the coalgebras for the costate comonad</a>”s are thrown around and there’s generally a lot sailing over my head.</p>
<p>On iota of wisdom that I pulled down from the stratosphere was that lenses are a kind of “getter” and “setter”, albeit ones with firm FP grounding. These can be used to effectively create flexible parameters to functions. “Flexible” just means:</p>
<ul>
<li>a pool of parameters to draw from</li>
<li>that are named rather than positional</li>
<li>and not all have to pe present</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="kw">import</span> Control.Lens
<span class="kw">import</span> Text.Printf

<span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> { _<span class="ot">firstName ::</span> <span class="dt">String</span>
                     , _<span class="ot">lastName ::</span> <span class="dt">String</span>
                     , _<span class="ot">email ::</span> <span class="dt">String</span>
                     }

makeLenses <span class="ch">''</span><span class="dt">Person</span>

<span class="co">-- use the &quot;email&quot; getter</span>
formatEmail p <span class="fu">=</span> printf <span class="st">&quot;&lt;%s&gt;&quot;</span> (p<span class="fu">^.</span>email)

<span class="co">-- issues a warning, but works.</span>
main <span class="fu">=</span> putStrLn <span class="fu">$</span> formatEmail (<span class="dt">Person</span>{_email<span class="fu">=</span><span class="st">&quot;chris@bendyworks.com&quot;</span>})</code></pre>
<p>Whew. It feels like cheating, but I really like how this works. Lenses let me “focus” on each field in my data structure by name (or position).</p>
<p>Lenses seem to fulfill the three bullets that I listed and they do so in the most “natural” way. I say that because, as Edward Kmett, goes into, lenses are useful for a bunch of other stuff and they compose really nicely:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> { <span class="co">-- ...like above...</span>
                     , _phone <span class="fu">=</span> <span class="dt">Phone</span> { _number <span class="fu">=</span> <span class="st">&quot;...&quot;</span>, _type <span class="fu">=</span> <span class="st">&quot;mobile&quot;</span> }
                     }

<span class="kw">data</span> <span class="dt">Phone</span> <span class="fu">=</span> <span class="dt">Phone</span> { _<span class="ot">number ::</span> <span class="dt">String</span>, _<span class="ot">type ::</span> <span class="dt">String</span> }

chris<span class="fu">^.</span>phone<span class="fu">^.</span><span class="kw">type</span> <span class="co">-- equals &quot;mobile&quot;</span></code></pre>
<p>So, in summary, I feel that lenses provide a credible solution to the named-record/non-positional/keyword arguments problem. Go forth and hack.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Well, <em>almost</em>. The ideal thing would be a typed record of some sort so that the function’s access would be guaranteed to be safe. If this weren’t the case then you’d have lost the safety that parameters give you. With parameters, it is instantly obvious if there’s one missing, the call is simply <em>wrong</em>. Likewise with typed records, accessing a field that doesn’t exist would be a compile-time error. In Ruby-style hash access, you’d just get a <code>nil</code> for any missing field/value.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
</article>

      </main>

    </div>
  </body>
</html>
